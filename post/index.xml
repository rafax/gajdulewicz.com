<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rafal Gajdulewicz</title>
    <link>http://gajdulewicz.com/post/</link>
    <description>Recent content in Posts on Rafal Gajdulewicz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Jul 2015 21:04:18 +0200</lastBuildDate>
    <atom:link href="http://gajdulewicz.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go gotchas - WaitGroup (and struct paramaters / method receivers)</title>
      <link>http://gajdulewicz.com/post/1/</link>
      <pubDate>Mon, 20 Jul 2015 21:04:18 +0200</pubDate>
      
      <guid>http://gajdulewicz.com/post/1/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; has been my go-to side project language for quite some time now (since before v1.0), and when I started the &lt;a href=&#34;http://cryptopals.com&#34;&gt;Matasano crypto challenges&lt;/a&gt; it seemed like a perfect fit for a number of reasons - it doesn&amp;rsquo;t force me to write a lot of boilerplate, is low-level enough to allow implementing your own crypto primitives and it comes with a rich standard library (I am looking at you Scala). I made my way through the first set and while solving one of the problems I wanted to run a certain function in parallel.&lt;/p&gt;

&lt;p&gt;The simplest way of making this use all CPU cores is to run each calculation in it&amp;rsquo;s own goroutine, and the standard way tracking if all of them completed is using a sync.WaitGroup - for simplicity&amp;rsquo;s sake this code assumes we only care about side effects (printing) and do not consume the result:

package main

import (
	&#34;fmt&#34;
	&#34;sync&#34;
)

func main() {
	numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	var wg sync.WaitGroup
	for _, n := range numbers {
		wg.Add(1)
		go func(in int) {
			fmt.Printf(&#34;%d: %d\n&#34;, in, cpuIntensive(in))
			wg.Done()
		}(n)
	}
	wg.Wait()
}

// does something CPU intensive
func cpuIntensive(n int) int {
	return n * n * n
}

This works fine, but wouldn&amp;rsquo;t it be nice to extract the anonymous function to make things more readable / testable:&lt;/p&gt;

&lt;p&gt;
package main

import (
	&#34;fmt&#34;
	&#34;sync&#34;
)

func main() {
	numbers := []int{1, 10, 100, 1000}
	var wg sync.WaitGroup
	for _, n := range numbers {
		wg.Add(1)
		go runInGoroutine(n, wg)
	}
	wg.Wait()
}

func runInGoroutine(in int, wg sync.WaitGroup) {
	fmt.Printf(&#34;cpuIntensive(%d): %d\n&#34;, in, cpuIntensive(in))
	wg.Done()
}

// does something CPU intensive
func cpuIntensive(n int) int {
	return n * n * n
}

Turns out it&amp;rsquo;s not that simple - this code completes the calculations but fails with
&lt;code&gt;
fatal error: all goroutines are asleep - deadlock!
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;What is happening here - we only extracted a function? Go is kind enough to let us know that our program is deadlocked - but why? Our simple refactoring wasn&amp;rsquo;t correct - we changed the way the code run in goroutine uses the sync.WaitGroup variable. Previously it closed (as in &lt;a href=&#34;https://en.wikipedia.org/wiki/Closure_(computer_programming&#34;&gt;closure&lt;/a&gt;) over it, now it takes it as a parameter.&lt;/p&gt;

&lt;p&gt;The issue is that the WaitGroup is passed by value, so each goroutine gets a copy of the WaitGroup. This means that when we call wg.Wait() we are waiting on a WaitGroup that will never be modified by child goroutines, and we will never exit the main function. The fix is simple - we pass a pointer to all goroutines, letting WaitGroup take care of concurrent modifications:

package main

import (
	&#34;fmt&#34;
	&#34;sync&#34;
)

func main() {
	numbers := []int{1, 10, 100, 1000}
	var wg sync.WaitGroup
	for _, n := range numbers {
		wg.Add(1)
		go runInGoroutine(n, &amp;wg)
	}
	wg.Wait()
}

func runInGoroutine(in int, wg *sync.WaitGroup) {
	fmt.Printf(&#34;cpuIntensive(%d): %d\n&#34;, in, cpuIntensive(in))
	wg.Done()
}

// does something CPU intensive
func cpuIntensive(n int) int {
	return n * n * n
}

Point to remember - whenever you are mutating parameters (or for that matter &lt;a href=&#34;https://tour.golang.org/methods/3&#34;&gt;method receivers&lt;/a&gt;) make sure you are referencing the original object, not a copy.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>